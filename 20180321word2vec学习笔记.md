---
title: word2vec学习问题简记
date: 2018-03-21 18:24:15
tags: Algorithm
categories: Machine Learning
---
为了表示对前辈的尊敬，  **[这篇文章](https://www.zybuluo.com/Dounm/note/591752)**建议所有做word2vector的人都应该拜读

关于模型的解释，很简单：

```
词 => 上下文  Skip-gram
上下文 => 词  CBOW Continuous Bag-of-words Model
```

损失函数是L =Σ𝑙𝑜𝑔𝑝(𝑤|𝐶𝑜𝑛𝑡𝑒𝑥𝑡(𝑤)),   w𝜖𝐶， 所以word2vec的关键问题：如何构造概率函数𝑝(𝑤|𝐶𝑜𝑛𝑡𝑒𝑥𝑡(𝑤))。实际上word2vector的损失函数用的是交叉熵。交叉熵是什么意思？这个要回归到香农熵定义当中去。

现有关于样本集的2个概率分布p和q，其中p为真实分布，q非真实分布。按照真实分布p来衡量识别一个样本的所需要的编码长度的期望(即平均编码长度)为：H(p) = Σp(i) * log(1/p(i))。如果使用错误分布q来表示来自真实分布p的平均编码长度，则应该是：H(p,q) = Σp(i) * log(1/q(i))。因为用q来编码的样本来自分布p，所以期望H(p,q)中概率是p(i)。H(p,q)我们称之为“交叉熵”。

也就是说，交叉熵越来越小的时候，错误分布就约逼近正确分布。

### 基于 Hierarchical Softmax 的模型

也就是分层softmax，它的提出是为了应对传统的神经网络语言模型最后输出层的计算复杂度的问题，由于传统的softmax分母在每一次训练完一个单词后，需要更新训练词典里面的所有单词，这个复杂度是无法忍受的，所以我们换了一种衡量概率的方式，用二叉树路径连乘来表示最后的概率，从以前训练词语的权值矩阵，转化到训练二叉树的路径权重。

#### 简单展开CBOW

假设：

- Context(w)由单词w的前后各c个词构成。
-  (Context(w)，w)为训练语料中的一个训练样例

三个分层为：输入层，投影层，输出层

* 输入层： 为Context(w)中的2c个词的词向量𝑣 (𝐶ontext(𝑤) 1) , 𝑣 (𝐶ontext( 𝑤 )2) , …𝑣 (𝐶ontext( 𝑤 )2𝑐−1) , 𝑣(𝐶ontext(𝑤)2𝑐)
* 投影层： 将输入层的2c个向量做求和，即Σ𝑣(𝐶𝑜𝑛𝑡𝑒𝑥𝑡(𝑤)𝑖)
* 输出层： 输出层对应一棵二叉树，它是以语料中出现过的词当叶子结点，以各词在语料中出现的次数当权值构造出的Huffman树。

具体的详细过程可以看[这个连接](http://hlt.suda.edu.cn/~xwang/slides/word2vector.pdf)，实际上还是根据概率的大小的来做预测，只不过概率模型做了深思熟虑的选择， 换句话说所有的学习都是建立在概率模型选择的基础之上的。而关于这个过程有几个问题要考虑：

- 输入层的词向量是怎么来的？
- 最后公式中为什么要用样本词向量的"和"乘以上文的词向量？

第一个问题的答案是我们认为初始化的，大多采用uniform分布来参考。第二个问题的答案是神经网络中所有的都是：线性变换+非线性，这样才能拟合任意函数，这是一方面，另一方面，这么做正是word2vec优化的地方所在，传统的神经网络语言模型是将所有的词向量组合成矩阵，每次训练都有大纬度的矩阵参与训练，这样太复杂了。另外一个优点是，舍弃了神经网络中的隐藏层。

#### Skip-gram

目的跟上文的CBOW相反，但是步骤是一样的，但是SG的复杂度更高了，因为它要预测所有上下文的词语，多了一层循环，即一对多。详细过程要知道如何推导。

### 基于Negative Sampling的模型

所以我一直搞不明白什么叫做Negative Sampling，就是因为取了负样本  而负样本的作用是什么？博客上说NS模型可以提高训练速度，并且改善词向量的质量。

实际上，Word2vec 本质上是一个语言模型，它的输出节点数是 V 个，对应了 V 个词语，本质上是一个多分类问题，但实际当中，词语的个数非常非常多，会给计算造成很大困难，所以需要用技巧来加速训练。

hierarchical softmax：本质是把 N 分类问题变成 log(N)次二分类

negative sampling：本质是预测总体类别的一个子集

那么针对标题开头的问题，NS 模型的本质，就是将训练集缩小到一个范围内，在这个范围内，目标词w作为正样本，其他词语作为负样本，而负样本的选择也有讲究，它摒弃了生冷词汇，按照单词出现的频率进行样本选择。


### 总结

我们要做的一切都是要求似然函数的最值，而所有的关键都在于构造合适的概率函数，那么我们思考选择什么样的模型比较合适呢？考虑到概率函数都是前向相乘的过程，所以我们要让那些频率高的词汇尽可能的排在前面，这样的话就可以避免掉很多不必要的乘法次数，所以Huffman模型能够很好的满足我们的要求。模型确定了以后剩下的就是数学的事情了。但是这么理解不对，Huffman树只是输出层的问题，不是训练，训练层中我们通过叠加向量+去掉隐藏层，达到了简化的目的，而输出层我们是为了规避softmax大量计算才采用的Huffman树，而不是训练方式。

还有一点就是词在Huffman树中都是以叶子节点的形式存在。

而有些同学不理解实际上它的训练过程是什么样子的，确实网络上的博客大部分都是在讲原理而没有讲落，[这篇文章](https://iksinc.online/tag/continuous-bag-of-words-cbow/)能够生动地讲述如何训练的。








